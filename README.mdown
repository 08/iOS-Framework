Building a static iOS framework is a pain in the ass. There are a variety of existing solutions
already and each one has its own disadvantage.

Existing Solutions
==================

A Google search for "iOS static framework" reveals the following Github project:
[https://github.com/kstenerud/iOS-Universal-Framework](https://github.com/kstenerud/iOS-Universal-Framework)

This project provides two solutions: "fake" frameworks and "real" frameworks.

A **fake** framework is a bundle target with a .framework extension and some post-build scripts to
generate the fat library for the .framework.

A **real** framework modifies the Xcode installation and generates a true .framework target. Real
frameworks also use post-build scripts to generate the fat library.

### Problems with Fake Frameworks

The problem with a fake framework is that you can't link to the framework as a dependent target. You
can "trick" Xcode into linking to the framework by using the `-framework` flag in your `LD_FLAGS`,
but changes to the framework will not be reflected in iterative builds. This requires that you clean
build every time you modify the framework, or make a trivial modification to the application itself
in order for it to forcefully relink to the new .framework. This bug is discussed
[here](https://github.com/kstenerud/iOS-Universal-Framework/issues/32).

*Example warning when you attempt to link to the .framework target:*

 warning: skipping file
'/Users/featherless/Library/Developer/Xcode/DerivedData/SimpleApp-cshmhxdgzacibsgaiiryutjzobcb/Build/Products/Debug-iphonesimulator/fakeframework.framework'
(unexpected file type 'wrapper.cfbundle' in Frameworks & Libraries build phase)

### Problems with Real Frameworks

To use real frameworks you need to modify your Xcode installation. This is simply not scalable when
you want to work with a team of people. If you use a build farm this problem becomes even worse
because it may not be possible to modify the Xcode installations on the build servers.

### Problems with Both Fake and Real Frameworks

In both frameworks there is a post-build step that builds the "inverse" platform. For example, if
you're building the framework for i386, the post-build step will build the framework for armv6/armv7
and then smush the libraries together into one fat binary within the framework. The problem with
this is that it **triples** the build time of the framework. Make one change to a .m file and
suddenly you're rebuilding it for three platforms. Change a PCH and your project will effectively
perform three clean builds. This is simply not ok from a productivity standpoint.

There is also the problem of distributing resources with the .framework. Both the fake and real
frameworks include an "embeddedframework" which is meant to be copied into the application. This
results in the .framework binary being distributed with the application! Alternatively we could ask
developers to only copy what's in the resources folder to their app, but this is complicated and
requires we namespace our resource file names to avoid naming conflicts.

The Ideal Solution
==================

There are a few constraints that we want to satisfy when building a .framework:

- Fast iterative builds when developing the framework. We may have a simple application that has the
  .framework as a dependency and we want to quickly iterate on development of the .framework.
- Infrequent distribution builds of the .framework.
- Want to be able to easily distribute resources with the framework.
- Setup for third-party developers using the .framework should be *easy*.

I believe that the solution I will outline below satisfies each of these constraints. I will outline
how to build a .framework project from scratch so that you can apply these steps to an existing
project if you so desire. I will also include project templates for easily creating a
.framework.

Overview
--------

Within the project we are going to have three targets: a static library, a bundle, and an aggregate.

The static library target will build the source into a static library (.a) and specify which headers
will be "public", meaning they will be accessible within the .framework.

The bundle target will contain all of our resources and will be loadable from the framework.

The aggregate target will build the static library for i386/armv6/armv7, generate the fat framework
binary, and build the bundle. You will run this target when you wish to build the .framework for
distribution.

When you are working on the framework you will likely have an internal application that links to the
framework. This application will link to the static library target as you normally would and copy
the .bundle in the copy resources phase. This has the benefit of only building the framework code
for the platform you're actively working on, significantly improving your build times. We'll do a
little bit of work in the framework project to ensure that you can use your framework in your app
the same way a third party developer would (i.e. importing <MyFramework/MyFramework.h> should work
as expected).

Create the Static Library Target
--------------------------------

### Step 1: Create a new "Cocoa Touch Static Library" project.

[![](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/newstaticlib.png)](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/newstaticlib.png)

The product name will be the name of your framework. For example, `Serenity` will generate
`Serenity.framework` once we've set up the project.

### Step 2: Create the primary framework header.

Developers expect to be able to import your framework by importing the `<Serenity/Serenity.h>`
header. Ensure that your project has such a header (if you created a new static library then there
should already be a Serenity.h and Serenity.m file; you can delete the .m).

Within this header you are going to import all of the public headers for your framework. For
example, let's assume that we have some `Widget` with a .h and .m. Our Serenity.h file would look
like this:

```
#import <Foundation/Foundation.h>

#import <Serenity/Widget.h>
```

Once you've created your framework header file, you need to make it a "public" header. Public
headers are headers that will be copied to the .framework and can be imported. This differs from
"project" headers which will *not* be distributed with the framework. This distinction is what
allows you to have a concept of public and private APIs.

To modify the scope of any header, select it in the project explorer and then expand the Utilities
pane (Cmd+Option+0).

[![](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/utilitiesbutton.png)](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/utilitiesbutton.png)

Look at the "Target Membership" group and ensure that the checkbox next to the .h file is checked.
Change the scope of the header from "Project" to "Public". This will ensure that the header gets
copied to the correct location in the copy headers phase.

[![](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/publicheaders.png)](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/publicheaders.png)

### Step 3: Update the public headers location

By default the static library project will copy private and public headers to the same folder,
`/usr/local/include`. To avoid mistakenly copying private headers to our framework we want to ensure
that our public headers are copied to a specific directory, say `Headers`. To change this setting
select the project in the file explorer and then click the "Build Settings" tab. Search for
"public headers" and then modify the setting for all configurations to be "Headers".

[![](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/publicheadersconfig.png)](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/publicheadersconfig.png)

### Ongoing step: Adding new sources to the framework

Whenever you add new source to the framework you must decide whether to expose the .h publicly or
not. To modify a header's scope you will follow the same process as Step 2.

### Step 4: Disable code stripping

We do not want to strip any code from the library; we leave this up to the application that is
linking to the framework. To disable code stripping we must modify the following configuration
settings:

    "Dead Code Stripping" => No (for all settings)
    "Strip Debug Symbols During Copy" => No (for all settings)
    "Strip Style" => Non-Global Symbols (for all settings)

### Step 5: Prepare the Framework

In order to use the static library as though it were a framework we're going to generate the basic
skeleton of the framework in the static library target. To do this we'll include a simple post-build
script. Add a post-build script by selecting your project in the file navigator and clicking the
"Build Phases" tab. From here, click "Add Build Phase" => "Add Run Script" and paste the following
script in the source portion of the run script build phase. You can rename the phase by clicking
the title of the phase (I've named it "Prepare Framework", for example).

    set -e

    mkdir -p "${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.framework/Versions/A"
    mkdir -p "${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.framework/Versions/A/Headers"

    # Link the "Current" version to "A"
    ln -sf A "${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.framework/Versions/Current"
    ln -sf Versions/Current/Headers "${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.framework/Headers"
    ln -sf "Versions/Current/${PRODUCT_NAME}" "${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.framework/${PRODUCT_NAME}"

    # The -a ensures that the headers maintain the source modification date so that we don't constantly
    # cause propagating rebuilds of files that import these headers.
    cp -a "${BUILT_PRODUCTS_DIR}/${PUBLIC_HEADERS_FOLDER_PATH}/" "${BUILT_PRODUCTS_DIR}/${PRODUCT_NAME}.framework/Versions/A/Headers"

[![](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/prepareframework.png)](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/prepareframework.png)

Try building your project now and look at the build products directory (usually
`~/Library/Developer/Xcode/DerivedData/<ProjectName>-<gibberish>/Build/Products/...`). You should
see a `libSerenity.a` static library, a `Headers` folder, and a `Serenity.framework` folder that
contains the basic skeleton of your framework.

[![](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/buildphase1.png)](https://github.com/jverkoey/iOS-Static-Framework/raw/master/gfx/buildphase1.png)
